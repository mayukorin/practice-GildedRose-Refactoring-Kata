# 壁打ちセッション #001: 初期ブレインストーミング

**日付**: 2025-12-29
**ステータス**: 進行中

---

## 今回の議論の目的

Gilded Roseプロジェクトでスペック駆動開発を実践するための、Claudeを活用した開発フローを設計する。

---

## 背景・前提

### やりたいこと
- リファクタリングの練習（Gilded Rose本来の目的）
- **スペック駆動開発の実践** ←新しい挑戦
- Claudeとの効果的な協働方法の確立

### 現状の理解
- Gilded Roseはレガシーコードのリファクタリング課題
- 要件仕様（GildedRoseRequirements.md）は存在する
- 既存コードは意図的に複雑な構造
- Itemクラスは変更禁止という制約がある
- Conjured itemsはまだ実装されていない

---

## 主要な論点

### 論点1: スペック駆動開発の定義と適用

**疑問**:
- スペック駆動開発とTDD/BDDの違いは？
- Gilded Roseのようなレガシーコードに対してどう適用する？
- 「仕様の形式化」とは具体的に何をすること？

**仮説**:
- 自然言語の要件 → 構造化された仕様 → テストケース → 実装
- レガシーコードの場合、まず現状の振る舞いを仕様化する必要がある
- 形式化により、仕様の曖昧さや矛盾を発見できる

**検討すべきこと**:
- [ ] どのレベルまで形式化すべきか？（数式？DSL？構造化テキスト？）
- [ ] 仕様とテストコードの関係性をどう保つ？
- [ ] 仕様の更新フローは？

### 論点2: Claudeの役割分担

**疑問**:
- どの工程をClaude に任せるべきか？
- 人間が必ず判断すべきポイントは？
- Claude に任せすぎるリスクは？

**仮説**:
- 機械的な作業（テストコード生成、仕様の構造化）はClaude が得意
- 設計判断や優先順位付けは人間が行うべき
- フィードバックループを短く保つことが重要

**検討すべきこと**:
- [ ] Claude-in-the-loopの具体的なワークフローは？
- [ ] Claudeの出力をどう検証する？
- [ ] 反復的な改善プロセスをどう設計する？

### 論点3: 段階的なアプローチ

**疑問**:
- どの順番で進めるのが効果的か？
- 小さく始めて拡大する戦略は？

**仮説**:
- まず1つのアイテムタイプで試す（例：Aged Brie）
- 成功パターンを他のアイテムに展開
- 最後にConjured itemsを追加

**検討すべきこと**:
- [ ] 最初に取り組むアイテムタイプは？（シンプル vs 複雑？）
- [ ] どこまで進めたら「成功」とみなすか？
- [ ] 学習曲線をどう設計するか？

### 論点4: 成果物と評価基準

**疑問**:
- 何を持って「スペック駆動開発ができた」とするか？
- どんな成果物を残すべきか？

**仮説**:
- テストカバレッジ100%が目標ではなく、仕様とコードの整合性が重要
- 成果物: 形式化された仕様、テストコード、リファクタリング済みコード、ドキュメント
- 再現可能なプロセスの確立も重要

**検討すべきこと**:
- [ ] 定量的な評価指標は必要か？
- [ ] ドキュメントのメンテナンス性をどう確保するか？
- [ ] 他のプロジェクトに応用できる形で知見を整理できるか？

---

## 具体的なワークフロー案（たたき台）

### 案A: トップダウンアプローチ

```
1. 全体の仕様を形式化（Claude支援）
2. 仕様から全テストケースを導出（Claude支援）
3. テスト実装（Claude生成、人間レビュー）
4. テストが通るようリファクタリング（人間主導、Claude支援）
```

**メリット**: 体系的、網羅的
**デメリット**: 初期投資が大きい、柔軟性が低い

### 案B: ボトムアップアプローチ

```
1. 1つのアイテムタイプを選ぶ（例：Aged Brie）
2. そのアイテムの仕様を形式化（Claude支援）
3. テストケース導出・実装（Claude生成、人間レビュー）
4. リファクタリング（人間主導、Claude支援）
5. 学びを記録し、次のアイテムタイプへ
```

**メリット**: 低リスク、学習しながら進められる
**デメリット**: 全体最適が見えにくい

### 案C: ハイブリッドアプローチ

```
1. 全体の仕様を軽く分析（Claude支援）
2. 優先度の高い部分から詳細化
3. テスト駆動で少しずつ実装・リファクタリング
4. 並行してドキュメント整備
```

**メリット**: バランスが良い
**デメリット**: 調整コストがかかる

---

## 開いている質問

### 技術的な質問
- [ ] JUnit 5のどの機能を活用すべきか？（Parameterized Test, Nested Test, etc.）
- [ ] Approval Testsは既存のものを使う？独自に作る？
- [ ] Property-based testingは適用できるか？
- [ ] モック・スタブは必要か？

### プロセスに関する質問
- [ ] 1イテレーションの単位は？（1アイテムタイプ？1機能？）
- [ ] レビューポイントをどこに設けるか？
- [ ] 問題が見つかったときのロールバック戦略は？

### Claude活用に関する質問
- [ ] プロンプトのテンプレート化は有効か？
- [ ] Claudeとの会話履歴をどう管理する？
- [ ] 生成されたコードの品質をどう担保する？
- [ ] 複数セッションにまたがる作業の一貫性は？

---

## 仮の結論・次のアクション

### 結論

**論点1「スペック駆動開発の定義と適用」について議論し、以下を決定**:

1. **要件定義書の最終成果物**: Gherkin記法ベースのドキュメント
2. **分析手法**: Gherkinで整理する前に、状態遷移図/デシジョンテーブルでテスト分析を実施
3. **開発フローの確立**: 4つのフェーズ（準備→要件収集・分析→振る舞いの形式化→Gherkin作成→振り返り）からなる反復的なフローを設計
4. **成果物管理**: アイテム毎/成果物種類毎にディレクトリを整理

### 次のアクション
- [x] 要件定義書策定フローをCLAUDE.mdにまとめる ✅ 完了
- [ ] 最初の実験対象アイテムを選定（推奨: Aged BrieまたはSulfuras）
- [ ] フェーズ1から実際にフローを実行開始
- [ ] iteration-1の振り返りで、フローの改善点を記録

---

## 議論メモ

### 議論の流れ

1. **論点の焦点化**
   - 開発フロー（プロセス）と具体的なテスト分析手法を分離
   - このセッションでは開発フローに集中することを決定

2. **基本方針の合意**
   - Q1: まず1つのアイテムタイプで試す（段階的アプローチ）
   - Q2: インプット = GildedRoseRequirements.md + 既存コード / アウトプット = Gherkin仕様書 + 分析資料
   - Q3: 反復的改善アプローチ

3. **フローの詳細設計**
   - v1フロー案の提示
   - フィードバックに基づくv2への改善
     - フェーズ1の成果物をアイテム毎ディレクトリに変更
     - レビューポイントの最適化（ステップ1-1, 1-2の個別レビューを廃止）
     - フェーズ3-2からフェーズ2への戻りルートを明記

### 気づき・アイデア

- **Gherkinの構造化**: 「アイテムに依らないドメインルール（Rule）」を抽出し、具体のScenarioをアイテム毎に配置する構造が有効
- **段階的な抽象化**: 状態遷移図/デシジョンテーブル（具体）→ Gherkin（抽象）という段階を踏むことで、仕様の網羅性と可読性を両立
- **反復の重要性**: 完璧を目指さず、フィードバックループを回すことで品質を向上させる

### 決定事項

1. **ディレクトリ構造**: 成果物種類別かつアイテム別の階層構造
   - `docs/requirements/[item-type]/` - フェーズ1成果物
   - `docs/analysis/[item-type].md` - フェーズ2成果物
   - `docs/specifications/gilded-rose.feature` - フェーズ3成果物（全アイテム統合）
   - `docs/retrospectives/iteration-[n].md` - フェーズ4成果物

2. **レビュータイミング**:
   - フェーズ1: ステップ1-3でまとめてレビュー
   - フェーズ2: ステップ2-1の都度レビュー（反復可）
   - フェーズ3: ステップ3-2でレビュー（フェーズ2への戻りも可）

3. **Claude/人間の役割分担**:
   - Claude: 分析・生成作業を主導
   - 人間: レビュー・判断・承認を担当
   - 重要な判断（差分確認、フェーズ間の戻り）は必ず人間が行う

### 保留事項

以下のトピックは次回以降のセッションで議論:
- 具体的なテスト分析手法（状態遷移図 vs デシジョンテーブルの使い分け）
- Gherkinの詳細な粒度設計
- テスト実装フロー（Gherkinからテストコードへの変換）
- リファクタリングフロー

---

## 参照ドキュメント

- [spec-driven-workflow.md](./spec-driven-workflow.md)
- [claude-collaboration-patterns.md](./claude-collaboration-patterns.md)
- [GildedRoseRequirements.md](../../GildedRoseRequirements.md)
- [GildedRoseRequirements_jp.md](../../GildedRoseRequirements_jp.md)

---

**次の壁打ちセッション**: TBD
