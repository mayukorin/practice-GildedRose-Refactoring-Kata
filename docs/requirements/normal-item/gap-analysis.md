# 通常アイテム - 要件とコードの差分分析

**作成日**: 2025-12-29
**分析対象**: 通常アイテム (Normal items)

## 分析対象ドキュメント

- **要件**: `docs/requirements/normal-item/requirements-extraction.md`
- **コード**: `docs/requirements/normal-item/code-analysis.md`

## 差分サマリー

| 項目 | 要件文書 | 実装コード | 一致 | 備考 |
|-----|---------|-----------|------|------|
| 毎日SellIn減少 | ○ (-1) | ○ (-1) | ✓ | 完全一致 |
| 期限内Quality減少 | ○ (-1) | ○ (-1) | ✓ | 完全一致 |
| 期限切れQuality減少 | ○ (-2) | ○ (-2) | ✓ | 完全一致 |
| Quality下限 | ○ (0) | ○ (0) | ✓ | 完全一致 |
| Quality上限 | ○ (50) | △ | △ | 通常アイテムでは増加しないため実質的に問題なし |
| sellIn=0の扱い | 曖昧 | 期限切れ扱い | - | **要確認** |
| SellIn下限 | 未記載 | なし（負の値が継続） | - | 実装を「正」とする |

## 詳細分析

### 1. 一致している項目

#### 1.1 基本的な劣化ルール

**要件**:
- 毎日、SellInとQualityが1減少する
- 販売期限切れ後は、Quality劣化が2倍速（-2）

**実装**:
- sellIn >= 1: quality -1, sellIn -1
- sellIn <= 0: quality -2, sellIn -1（フェーズ1で-1、フェーズ3でさらに-1）

**判定**: ✓ 一致

#### 1.2 Quality下限制約

**要件**:
- Quality値は決してマイナスにはならない（下限: 0）

**実装**:
- フェーズ1, フェーズ3ともに `if (quality > 0)` でガード
- quality = 0 になると、それ以上減少しない

**判定**: ✓ 一致

### 2. 実質的に問題ない差分

#### 2.1 Quality上限（50）

**要件**:
- Quality値は50以上にはならない（上限: 50）

**実装**:
- 通常アイテムのコードには、quality上限チェックが存在しない
- ただし、通常アイテムは**quality が減少するのみ**なので、初期値が50以下であれば上限超過は起こりえない

**判定**: △ 実装上は問題ないが、仕様として明示的なチェックはなし

**推奨**:
- 初期値バリデーションで quality <= 50 を保証すれば十分
- または、リファクタリング時に明示的なチェックを追加（防御的プログラミング）

### 3. 要確認の差分

#### 3.1 sellIn = 0 の日の扱い ⚠️

**要件の記述**:
> 「販売するための残り日数が無くなると、Quality値は2小さくなります」

**解釈の余地**:
- 解釈A: sellIn = 0 は「まだ残り日数がある」→ quality -1
- 解釈B: sellIn = 0 は「残り日数が無い」→ quality -2

**実装の振る舞い**:
- sellIn = 0 の日: quality -2（解釈B）
- 理由: sellInを減少させた**後**に `sellIn < 0` を判定するため、sellIn = 0 → -1 となった時点で期限切れ扱い

**コード実装の詳細**:
```java
// フェーズ1: quality -= 1
if (items[i].quality > 0) {
    items[i].quality = items[i].quality - 1;
}

// フェーズ2: sellIn減少
items[i].sellIn = items[i].sellIn - 1;  // 0 → -1

// フェーズ3: 減少後のsellInで判定
if (items[i].sellIn < 0) {  // -1 < 0 → true
    if (items[i].quality > 0) {
        items[i].quality = items[i].quality - 1;  // さらに -1
    }
}
```

**判定**: 実装は**解釈B**（sellIn = 0 も期限切れ）を採用

**質問**:
- この実装を「正」として仕様化してよいか？
- それとも、要件の意図は解釈Aで、実装にバグがあると考えるか？

**推奨アクション**:
1. TextTestフィクスチャで sellIn = 0 のケースを確認
2. この振る舞いを「正」とする場合、Gherkin仕様書に明記
3. 解釈Aが正しい場合、実装を修正（ただし、これはリファクタリングではなく仕様変更になる）

#### 3.2 SellIn値の下限

**要件**:
- SellIn値の下限について明示的な記載なし

**実装**:
- SellIn値は負の値が継続的に減少する（下限なし）
- 例: sellIn = -1 → -2 → -3 → ...

**判定**: 実装を「正」とする

**理由**:
- 要件に制約がない以上、実装の振る舞いを仕様とみなす
- 実用上、sellIn が負の値でどこまでも減少することに問題はない

### 4. エッジケース

#### 4.1 quality = 1, sellIn < 0 のケース

**実装の振る舞い**:
- フェーズ1: quality = 1 → 0
- フェーズ3: quality = 0 → `quality > 0` が false → スキップ
- 結果: quality -1（-2にはならない）

**判定**: ✓ 下限制約が正しく機能している

#### 4.2 quality = 2, sellIn = 0 のケース

**実装の振る舞い**:
- フェーズ1: quality = 2 → 1
- フェーズ2: sellIn = 0 → -1
- フェーズ3: quality = 1 → 0
- 結果: quality -2, sellIn -1

**判定**: ✓ 期限切れ劣化が正しく機能している

## 推奨される仕様確定方針

### 採用すべき仕様（実装ベース）

1. **sellIn = 0 の扱い**: 期限切れ扱い（quality -2）
   - 理由: 既存実装がこの振る舞いをしており、変更すると既存の振る舞いが変わる
   - Gherkin仕様書では、この点を明確に記載する

2. **SellIn下限**: なし（負の値が継続的に減少）
   - 理由: 要件に制約がなく、実装上も問題ない

3. **Quality上限**: 初期値バリデーションで保証
   - 理由: 通常アイテムは減少のみなので、実装チェックは不要

### 次フェーズへの引き継ぎ事項

**フェーズ2（振る舞いの形式化）で重点的に扱うべき項目**:
- sellIn = 0 の境界条件
- quality = 0, 1, 2 の各値での期限切れ劣化
- sellIn の正→0→負への遷移

**Gherkin仕様書で明記すべき項目**:
- 「販売期限切れ」の定義: sellIn < 0（つまり、sellIn = 0 の日にすでに期限切れ扱い）
- Quality下限: 0（厳格に守られる）
- 期限切れ時のquality減少が「最大」-2であること（quality = 1 の場合は -1 で停止）

## 結論

**フェーズ1の完了判定**: ✓ OK

**理由**:
- 重要な差分（sellIn = 0 の扱い）を特定できた
- 実装を「正」とする方針を推奨
- 次フェーズで形式化すべき境界条件を明確化できた

**次のステップ**:
- 人間レビューで、sellIn = 0 の扱いについて合意
- フェーズ2（振る舞いの形式化）へ進む
